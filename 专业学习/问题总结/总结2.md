#### 使用redis存储数据，数据量很小，但是需要可靠性极强，使用哪种方式存储（AOF,RDB）?

- 如果非常关系数据的安全，应该使用AOF加RDB混合使用。RDB已一定的频率执行，两次快照之间使用AOF日志记录这期间所有的命令操作。
- 如果可以承受分钟级别的数据丢失，可以只使用RDB。
- 如果只使用AOF，优先使用everysec，因为在可靠性和性能之间取了一个平衡

#### mysql 的锁有哪些？mysql的事务隔离级别是怎么实现的？

- 全局锁：对整个数据库加锁。全库逻辑备份。
- 表级锁：表锁，元数据锁。表锁可以指定 read，还是write，阻塞读写语句。元数据锁无需显示调用，访问一个表的时候会被自动加上，对标做增删盖茶操作都加上元数据读锁MDL锁。
- 行锁：在需要的时候加上，事务结束才释放，两阶段锁协议。死锁避免，自动超时，死锁检测，回滚一个事务，检测时间复杂度是O(n) 一般要在业务上控制并发度。

##### 事务实现

- 读未提交：直接查询的是记录的最新值，没有视图的概念。
- 读提交：视图的创建是在每个sql语句执行的时候创建的。
- 可重复读：视图是在事务启动的时候创建。
- 每条数据记录在更新的时候，同时会记录一条回滚操作。同一条记录可以在系统中存在多个版本。

#### mysql的字段如果能在业务上保证唯一性，在这个字段上使用唯一索引还是普通索引好？

使用普通索引，两者在查询场景下没什么区别，在写的时候，普通索引在更新的时候速度更快，普通索引更新时可以使用change buffer，减少了随机读，因为唯一索引需要判断数据的唯一性，每次需要先查询，如果数据页不在内存中，则需要将数据页读入内存，而普通索引这只需要直接记录到change buffer。但是如果有写后，立马读的场景很多，则将change buffer 关闭。

#### mysql 的执行计划解读？

- type：查询所用到方式
  - ALL 全表扫描
  - index 
  - range
  - ref
  - eq_ref
  - const,system
  - NULL
- possible_keys：可能用到的索引
- key：当前使用的索引
- key_len：使用的索引的字节数
- extra：
  - using index 标识使用到了覆盖索引 
  - using temporary 使用临时表存储结果集，分组
  - using filesort 无法使用索引完成的排序称为“文件排序”

#### concurrentHashMap 1.8设计的缺点？

#### mysql有哪些索引类型？

- 哈希表：适合等值查询
- 有序数组：等值查询和范围查询，只适合与静态数据不修改，比如2015年某学校新生信息。
- B+树：数据都存在叶子结点，特点是矮胖，减少磁盘IO。主键索引叶子结点是存的整行数据，聚簇索引。非聚簇索引，存索引加主键值，这种有可能要回表操作。

#### hashMap为什么线程不安全？

- 并发写，更新数据没有加锁或者任何同步操作。1.8之前在多线程同时扩容的情况下可能会造成环形链表，导致后续查询进入死循环。

#### mq是如何保持顺序写与顺序读？

- RabbitMQ：往队列中投递消息都是有序的，是因为多个消费者消费同一个queue导致，消息消费可能顺序错乱。解决方案是，使用多个queue每个消费者消费不同的queue。
- Kafka：一个topic下的一个partition肯定是有序的，生产的时候可以指定一个key，同一个key会发到同一个partition中，所以消费者，收到的消息也是有序。但是消费者开多线程消费。可能导致顺序错乱。线程处理前加上消费队列，每个线程只负责处理其中一个内存队列。
- 顺序消费：在生产端保证有序后，消费端采取主动拉去的方式也可保证消费有序。

#### mysql设计唯一索引字段的选择是如何考量的？

首先考虑那个字段使用的查询场景最广，如果都一样的话，考虑字段的存储大小，毕竟索引存储也是需要大小的。

#### tcp四次挥手中time_wait 的作用？过多的close_wait的原因？

- 保证客户端最后一个ack可以到达服务器，因为可能丢失，这样服务端没有收到会重发FIN，这样客户端就可以接收到了，并且重新激活倒计时。另外方式已经失效的报文出现。客户端完成最后一个报文确认，可以让服务端所有的失效报文得到清除，保证不影响新的链接。
- 服务端未调用close方法，关闭socket，也就不会传FIN包