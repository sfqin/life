#### mysql 查询语句执行过程

1. 连接器：账号登录建立连接获取权限加载到内存，如果账号权限被修改，不会影响已经建立的链接。
2. 查询缓存：缓存中有类似 k-v 形式的存储，如果命中缓存则直接返回。
3. 分析器：词法分析，将关键词识别出来，将字符串识别为相应的表，列。语法分析，检查语法是否有错误。
4. 优化器：如果表有多个索引是，决定使用哪个索引。或者在join时候，决定各个表的先后连接顺序。
5. 执行器：执行最终的语句，这个时候会判断是否有表的查询权限，如果有则跟进不同的表的引擎调用不用引擎提供的接口去执行查询。

### 更新语句执行流程

1. 连接器：账号登录建立连接
2. 处理缓存：将这个表上的所有缓存清空
3. 分析器：词法分析，语法分析
4. 优化器：索引选择（要先查询后修改）
5. 执行器：调用引擎接口执行更新 （redo log innodb独有, bin log server层日志，都有）

### redo log 与 bin log

redo log innodb独有, bin log server层日志, 所有引擎都有。redo log 大小有限 wal机制循环写入，先写入 redo log buffer中，批量写入日志，事务提交许多日志一起写入磁盘，redolog也是文件需要磁盘io，但是redolog是顺序写，并且了个组提交，所以快很多，还有一些别的优化。
redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；
组提交机制，可以大幅度降低磁盘的 IOPS 消耗
binlog 的三种格式 statement row mixed，statement 记录的就是sql语句同一个sql语句放到不同的实例上执行可能存在数据不一致（索引选择不同）。row格式的记录记录操作前的完整数据，所以很占空间。 mixed 折中方案，mysql自己判断sql语句是否可能引起主备不一致，如果有可能就会使用row，否则使用statement。

### mysql 事务（ACID）隔离级别

read-uncommitted 脏读，不可重复读，幻读
read-committed 不可重复读，幻读
repeatable-read 幻读
seaializable

### mysql 的索引存储结构

索引的存储是在引擎层实现的
哈希表-适用等值查询
有序数组-使用存档，不更新
搜索树-innoDB引擎的索引存储使用的是B+树，每个索引就是一颗B+树，根据叶子节点内容可以分为主键索引与非主键索引。主键索引也被称为聚簇索引，存储的是整行数据的内容。非主键索引也被称为二级索引，存储的是索引字段的值与主键的值。为什么不使用b树或者二叉树。 B+树相比其他树的特点就是矮胖，这样的特点的好处是每次查询从根节点搜索到叶子结点时候，由于这个矮，可以大大缩短搜索的次数，从而可以加速查询。
覆盖索引：查询所需要的的结构已经在索引上了，不需要回表操作，可以显著的提高查询性能。

### 索引失效场景

最左匹配原则：建立联合索引时，可以通过调整顺序，可以减少索引的维护
where的索引字段是负向条件时，索引字段使用函数，where条件有or，where条件有前导模糊查询 like "%XX"，数据类型发生隐式转换（int类型的a where a = "1",join 时候 两个表的字符集不一样）

### mysql中的锁

全局锁：对整个数据库实例加锁，Flush tables with read lock (FTWRL) 整个库出于只读状态，其它语句都会被阻塞。 应用场景：全库逻辑备份。
表级锁：表锁 lock tables … read/write，元数据锁（meta data lock，MDL） MDL锁不需要显示指定，访问一个表（所有对表的增删改查操作都需要先申请 MDL 读锁）时会被自动加上
行锁：引擎层实现，myisam不支持，innodb支持可以大大提高并发访问效率。 两阶段提交：需要的时候才加上，事务提交后或者事务回滚才释放。建议：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
死锁检测策略：设置超时时间，另外一个是发起死锁检测，将其中一个事务回滚释放资源。

### 数据更新 change buffer

数据页在内存就直接更新，数据页不在内存会将这些更新操作缓存在change buffer中，change buffer是 buffer pool的一部分。下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer 中与这个页有关的更新操作。change buffer 在内存中有，也会被写到磁盘上，事务提交时候写到redo log中。 唯一索引更新用不到，普通索引更新可以用到。因为唯一索引必须判断唯一键约束所以必须将数据加载到内存中的 buffer pool 中，所以直接更新就行。

### mysql优化器索引选择错误

扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。 解决方法 1.使用force index, 2. 修改语句，引导mysql使用我们期望的索引。3. 建立一个更好的索引，提供给优化器选择

### 数据可靠性的保证（mysql 宕机了）

首先redo log（物理日志）是innodb 引擎特有的日志，大小有限 wal机制循环写入，用于保证crash-safe能力
binlog 是所有引擎都有的是用做归档的，高可用架构就是依赖binlog来实现的
而binlog与redo log之间的联系是他们都有一个共同的数据字段叫 XID。
而mysql的日志是两阶段提交的 首先些人redolog，出于prepare阶段，然后写binlog，提交事务（处于commit阶段）。
而可靠性，我理解是两方面的，第一方面，就是宕机了，重启后本实例的数据是完整的，第二点就是重启后保证binlog是正确的完整的，因为有些高可用架构数据之间的一致性是强依赖binlog的。
如果发生宕机看时机
写入redo log 出于prepare阶段之后，写入binlog之前崩溃。此时binlog还没有写，redo log也还没提交，所以恢复时候，这个事务直接回滚，这时候binlog还没写也不会传到备库。
写完binlog后崩溃。log中事务是完整的也就是有commit标识，则直接提交。如果只有prepare标识，则判断binlog是否存在并且完成，如果是则提交事务，否则回滚事务。
binlog 先写到内存 binlog cache（太大了就会存在磁盘），事务提交binlog cache 写入binlog文件。 

### 主备延迟

1. 备库所在机器性能比主库差
2. 备库压力大（执行一些后台查询分析语句）
3. 大事务

### 主备切换

> mysql的高可用系统的可用性是依赖于主备延迟的，延迟越小，主库故障恢复的时间越短，可用性就越高

##### 可靠性优先原则

1. 判断备库延迟小于一定值比如5s
2. 将主库改为只读
3. 等待备库延迟为0，也就是所有binlog都执行完成
4. 把备库B改为读写状态
5. 将业务切换到备库

#####  可用性优先原则

1.  直接切换，代价是可能数据不一致
   

#### 备库执行binlog过程 

1. 首先A,B两个实例，数据状态一样在备库B上执行 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个日志文件和偏移量来请求 binlog
2. 备库B 执行 start slave 命令，这时候备库会启动两个线程，io_thread和sql_thread,io_thread 负责与主库建立连接
3. 主库A校验完用户名和密码，开始按照备库B传过来的位置，从本地读取binlog,发送给B
4. 备库B拿到binlog后写到本地文件，中转日志(relay log)中
5. sql_thread 读取中转日志，解析日志中的命令，并执行
   

###  GTID 有什么用？

5.6 新特性 主要解决主从同步时候可能发生错误问题，GTID 全局事务，是由 serveruuid_transactionid 共同组成，每个实例都维护自己的GTID集合，在主从切换时候，从库只需要将自己的GTID集合发送给主库，主库判断自己存在的但是从库不存在的GTID，然后检索这些GTID的binlog是否完整，如果不完整直接报错，如果完整则直接从这个地方开始往从库发送binlog。不像之前mysql的复制需要从库自己指定从主库的binlog位置来同步数据，这样在主库发生故障，切换备库的时候，从库在切换主库的时候，这个同步位点查找有一定误差，可能会导致 主键冲突，或者删除数据不存在。

一次查询数据量很大，内存不会爆，结果集是边获取，边发送，但是客户端如果接收慢就可能堵住sql语句

### mysql join操作算法

Index Nested-Loop Join 驱动表中查询出来一行，然后再去被驱动表中查找响应结果一起返回，重复这个步骤。
Block Nested-Loop Join 驱动表扫描行数太大用不上索引，则会将被驱动表加载到内存，如果内存不足则分段加载，然后和INJ算法一致。 explain 语句如果 Extra字段有说明 尽量不要使用
尽量使用小表作为驱动表，小表的判断规则是，两个表按照各自的条件过滤后，计算参与join的各个字段总数据量，数据量小的就是小表，应该作为驱动表
使用left join，左边的表不一定是驱动表，如果需要使用left join语义的话，就不能把被驱动表的字段放在where条件里面做等值判断或者不等值判断，必须写在on里面

### 临时表与内存表的区别

内存表指的是使用memory引擎创建的表，这种表数据保存在内存中，系统重启后数据会被清空，但是表结构还在。
临时表可以使用各类引擎，如果使用innodb引擎创建的临时表，数据也是写在磁盘上的，临时表只对当前线程可见，临时表可以与普通表同名，临时表还可以改名，因为底层存的.frm文件的前缀是#sql{进程 id}_{线程 id}_ 序列号

> 使用 distinct 与 group by 单纯去重的话执行流程一样，性能也一样。过程都是创建一个临时表，把分组字段作为唯一索引，依次查询到满足条件的数据插入临时表，如果主键冲突就跳过，完成后将结果返回客户端

### 自增主键id

自增主键达到最大值后，再申请下一个id，就不会变了。
如果不指定主键会自动创建一个row_id，长度为6个字节，就相当于自增id。row_id 到达最大值后，会重新归0开始递增。
XID是由server维护的， innodb的 trx_id 是自己维护的