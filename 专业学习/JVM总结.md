## JVM内存模型

- 程序计数器：一块较小的内存区，存放当前程序执行的字节码指令地址，当前线程执行的是本地方法，计数器为undefined。在多线程情况下，线程切换回来时就知道上次线程执行到什么位置了。线程私有的，不会出现oom
- Java虚拟机栈：描述java方法运行过程的内存模型。每个运行的java方法都会创建一个叫做栈帧的区域，用于存放方法运行过程中的一些信息，如局部变量，操作数栈，动态链接，方法出口信息等。当一个方法中调用新的方法，会创建新的栈帧，压入栈顶，方法执行结束，栈帧被移除。线程私有，会出现两种异常 StackOverflowError 栈深度太大，超过最大值。OOM 内存用完。
- 本地方法栈：与Java虚拟机栈类似，描述本地方法运行的内存模型
- 方法区：Java虚拟机规范中定义是堆的一个逻辑部分。存放已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码。线程共享，存储的都是长期存在的对象，因此又被称为“永久代”。内存回收率低，主要回收目标是常量池，类型的卸载。允许固定大小，也允许动态扩展，还允许不实现垃圾回收。常量就存在常量池中，当类被Java虚拟机加载后，.class文件中的常量就存放在方法区的运行常量池。而运行期间也能向常量池中添加新的常量。
- 堆：一个Java虚拟机只有一个堆，所有的线程共享，在虚拟机启动时创建，是垃圾回收的主要场所。进一步细分为新生代（Eden区，From survior，To surivor）、老年代。不同区域存放不同的生命周期的对象。堆的大小既可以固定也可以扩展，主流虚拟机堆大小是可以扩展的，可能会出现OOM异常。
- 直接内存（堆外内存）：虚拟机之外的内存，也可使用。在NIO中引入了一种基于通道和缓冲的IO方式，可以直接通过本地方法直接分配本地内存，通过堆中的DirectByteBuffer直接操作内存，无须将外部内存中的数据复制到堆中再进行操作，大大提高了数据操作的效率。大小不受Java虚拟机的控制，也可能出现OOM。与堆内存相比，申请空间耗费更高性能，读取IO由于普通堆内存。